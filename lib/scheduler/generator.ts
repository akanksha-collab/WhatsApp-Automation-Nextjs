import { connectDB } from '@/lib/db/connect';
import { Entity, IEntityDocument } from '@/lib/db/models/Entity';
import { ScheduledPost } from '@/lib/db/models/ScheduledPost';
import { ScheduleSettings } from '@/lib/db/models/ScheduleSettings';
import { MessageTemplate, IMessageTemplateDocument } from '@/lib/db/models/MessageTemplate';
import { calculatePriority, sortByPriority, EntityPriority } from './priority';
import { selectContent } from './rotation';
import { 
  findBestMatchingTemplate, 
  mapEntityPriorityToTemplatePriority,
  EntityPriorityLevel 
} from './template-matcher';
import { addDays, setHours, setMinutes, startOfWeek, format, differenceInDays } from 'date-fns';
import { toZonedTime } from 'date-fns-tz';

interface GenerateWeeklyScheduleParams {
  userId: string;
  weekStartDate?: Date;
}

/**
 * Generate a unique key for tracking templates used per entity per day
 */
function getEntityDayKey(entityId: string, date: Date): string {
  return `${entityId}-${format(date, 'yyyy-MM-dd')}`;
}

export async function generateWeeklySchedule({
  userId,
  weekStartDate,
}: GenerateWeeklyScheduleParams): Promise<number> {
  await connectDB();
  
  // Get user's schedule settings
  const settings = await ScheduleSettings.findOne({ userId });
  if (!settings) throw new Error('Schedule settings not configured');
  
  // Get all active entities
  const entities = await Entity.find({ userId, status: 'active', isActive: true });
  if (entities.length === 0) return 0;
  
  // Calculate priority for each entity
  const prioritizedEntities = entities.map(e => calculatePriority(e, settings));
  const sortedEntities = sortByPriority(prioritizedEntities);
  
  // Get all active templates
  const templates = await MessageTemplate.find({ userId, isActive: true }).lean() as IMessageTemplateDocument[];
  
  // Determine week start
  const weekStart = weekStartDate || startOfWeek(new Date(), { weekStartsOn: 1 });
  
  // Cancel existing scheduled posts for this week
  await ScheduledPost.deleteMany({
    userId,
    status: 'scheduled',
    isAutoGenerated: true,
    scheduledAt: {
      $gte: weekStart,
      $lt: addDays(weekStart, 7),
    },
  });
  
  // Generate posts for each day
  const postsToCreate: Record<string, unknown>[] = [];
  const templateUsageUpdates: Map<string, number> = new Map();
  
  // Track templates used per entity per day to prevent same-day repetition
  // Key: "entityId-yyyy-MM-dd", Value: Set of template IDs used that day
  const usedTemplatesPerEntityDay: Map<string, Set<string>> = new Map();
  
  for (let dayOffset = 0; dayOffset < 7; dayOffset++) {
    const currentDate = addDays(weekStart, dayOffset);
    const dayName = format(currentDate, 'EEEE').toLowerCase();
    
    // Get day settings
    const daySettings = settings.weeklySchedule.find(d => d.day === dayName);
    if (!daySettings?.isActive) continue;
    
    // Get active time slots for this day
    const activeSlots = daySettings.timeSlots.filter(s => s.isActive);
    
    // Distribute entities across time slots based on priority
    const slotsWithPosts = distributeEntities(
      sortedEntities,
      activeSlots,
      currentDate,
      settings.timezone
    );
    
    for (const slot of slotsWithPosts) {
      if (!slot.entity) continue;
      
      // Select content for this entity
      const content = await selectContent(slot.entity.entity, settings);
      if (!content) continue;
      
      // Map entity priority to template priority
      const templatePriority = mapEntityPriorityToTemplatePriority(slot.entity.priorityLevel as EntityPriorityLevel);
      
      // Get the exclude list for this entity on this day
      const entityDayKey = getEntityDayKey(slot.entity.entity._id.toString(), currentDate);
      const usedTemplateIds = usedTemplatesPerEntityDay.get(entityDayKey) || new Set<string>();
      
      // Find best matching template (now matches by priority only, excludes already used today)
      const templateMatch = findBestMatchingTemplate(
        templates,
        templatePriority,
        Array.from(usedTemplateIds)
      );
      
      // Generate message
      let message: string;
      let usedTemplateId: string | undefined;
      let usedTemplateName: string | undefined;
      
      if (templateMatch) {
        message = applyTemplate(templateMatch.template.template, slot.entity.entity);
        usedTemplateId = templateMatch.templateId;
        usedTemplateName = templateMatch.templateName;
        
        // Add to used templates for this entity on this day
        usedTemplateIds.add(usedTemplateId);
        usedTemplatesPerEntityDay.set(entityDayKey, usedTemplateIds);
        
        // Track template usage for batch update
        const currentCount = templateUsageUpdates.get(usedTemplateId) || 0;
        templateUsageUpdates.set(usedTemplateId, currentCount + 1);
      } else {
        message = generateDefaultMessage(slot.entity.entity);
        usedTemplateName = 'Default Message (No Templates)';
      }
      
      postsToCreate.push({
        userId,
        entityId: slot.entity.entity._id.toString(),
        contentType: content.contentType,
        mediaUrl: content.mediaUrl,
        mediaPublicId: content.mediaPublicId,
        message,
        link: content.link,
        templateId: usedTemplateId,
        templateName: usedTemplateName,
        scheduledAt: slot.scheduledTime,
        scheduledDay: dayName,
        timeSlotId: slot.slotId,
        status: 'scheduled',
        priority: slot.entity.score,
        isAutoGenerated: true,
      });
    }
  }
  
  // Bulk insert posts
  if (postsToCreate.length > 0) {
    await ScheduledPost.insertMany(postsToCreate);
    
    // Update template usage counts
    for (const [templateId, usageCount] of templateUsageUpdates) {
      await MessageTemplate.findByIdAndUpdate(templateId, {
        $inc: { usageCount: usageCount },
        $set: { lastUsedAt: new Date() },
      });
    }
  }
  
  return postsToCreate.length;
}

function distributeEntities(
  entities: EntityPriority[],
  slots: { id: string; time: string }[],
  date: Date,
  timezone: string
): { slotId: string; scheduledTime: Date; entity: EntityPriority | null }[] {
  const result: { slotId: string; scheduledTime: Date; entity: EntityPriority | null }[] = [];
  
  // Create a pool of entities weighted by priority
  const entityPool: EntityPriority[] = [];
  for (const entity of entities) {
    // Add entity multiple times based on frequency multiplier
    const count = Math.ceil(entity.frequencyMultiplier);
    for (let i = 0; i < count; i++) {
      entityPool.push(entity);
    }
  }
  
  // Shuffle pool for randomness while maintaining priority bias
  const shuffled = entityPool.sort(() => Math.random() - 0.5);
  
  let entityIndex = 0;
  for (const slot of slots) {
    const [hours, minutes] = slot.time.split(':').map(Number);
    let scheduledTime = setHours(setMinutes(date, minutes), hours);
    scheduledTime = toZonedTime(scheduledTime, timezone);
    
    result.push({
      slotId: slot.id,
      scheduledTime,
      entity: shuffled[entityIndex] || null,
    });
    
    entityIndex = (entityIndex + 1) % shuffled.length;
  }
  
  return result;
}

function formatDateSafe(date: Date | undefined | null, formatStr: string = 'MMMM d, yyyy'): string {
  if (!date) return '';
  try {
    return format(new Date(date), formatStr);
  } catch {
    return '';
  }
}

function applyTemplate(template: string, entity: IEntityDocument): string {
  // Calculate days remaining until lead plaintiff deadline (just the number)
  let daysRemaining = '';
  if (entity.leadPlaintiffDate) {
    const days = differenceInDays(new Date(entity.leadPlaintiffDate), new Date());
    if (days >= 0) {
      daysRemaining = String(days);
    } else {
      daysRemaining = '0'; // Deadline passed
    }
  }

  return template
    // Basic Info
    .replace(/\[Company Name\]/gi, entity.companyName || '')
    .replace(/\[Ticker\]/gi, entity.tickerSymbol || '')
    // Dates
    .replace(/\[Lead Plaintiff Deadline\]/gi, formatDateSafe(entity.leadPlaintiffDate))
    .replace(/\[Days Remaining\]/gi, daysRemaining)
    .replace(/\[Class Period Start\]/gi, formatDateSafe(entity.classPeriodStart))
    .replace(/\[Class Period End\]/gi, formatDateSafe(entity.classPeriodEnd))
    .replace(/\[Case Date\]/gi, formatDateSafe(entity.caseDate))
    // Case Details
    .replace(/\[Allegations\]/gi, entity.allegations || '')
    // Links
    .replace(/\[Join Link\]/gi, entity.joinLink || '')
    .replace(/\[Blog Link\]/gi, entity.blogLink || '')
    .replace(/\[YouTube Link\]/gi, entity.youtubeLink || '')
    .replace(/\[Podcast Link\]/gi, entity.podcastLink || '')
    .replace(/\[Avatar Video\]/gi, entity.avatarVideo || '')
    .replace(/\[AI Video\]/gi, entity.aiVideo || '');
}

function generateDefaultMessage(entity: IEntityDocument): string {
  let message = `ðŸš¨ ${entity.companyName} (${entity.tickerSymbol}) Securities Class Action\n\n`;
  
  message += `Lead Plaintiff Deadline: ${formatDateSafe(entity.leadPlaintiffDate)}\n`;
  
  if (entity.classPeriodStart && entity.classPeriodEnd) {
    message += `Class Period: ${formatDateSafe(entity.classPeriodStart)} to ${formatDateSafe(entity.classPeriodEnd)}\n`;
  }
  
  if (entity.allegations) {
    message += `\n${entity.allegations}\n`;
  }
  
  message += `\nContact us to learn about your legal options.`;
  
  if (entity.joinLink) {
    message += `\n\nðŸ‘‰ ${entity.joinLink}`;
  }
  
  return message;
}
